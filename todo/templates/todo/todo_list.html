<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Todo List</title>
</head>
<body>
    <h1>Things I need to do:</h1>
    <table>
        {% for item in items %}
        <tr>
            {% if item.done %}
                <td><strike>{{ item.name}}</strike></td>
            {% else %}
                <td>{{ item.name}}</td>
            {% endif %}
            <td>
                <a href="/toggle/{{item.id}}">
                    <button>Toggle</button>
                </a>
            </td>
            <td>
                <a href="/edit/{{item.id}}">
                    <button>Edit</button>
                </a>
            </td>
            <td>
                <a href="/delete/{{item.id}}">
                    <button>Delete</button>
                </a>
            </td>
        </tr>
        {% empty %}
        <tr>
            <td>You have nothing to do</td>
        </tr>
        {% endfor %}
    </table>
    <a href="/add">Add item</a>
</body>
</html>

<!-- 
The next thing to do is to update our view function. So that instead of 
returning this long string of HTML, it returns our template instead.

A query set is like a list, which means we can iterate through it in our
template just like we could iterate through a list in Python.

"{{ items }}" renders the items key from the context dictionary from our views.py file. 
this double curly bracket syntax is called a "template variable" 
Anything that you return to the template in that dictionary can be rendered in the same way. 
That includes almost anything that you can use in Python Meaning you can return strings, 
numbers, lists, other dictionaries, or even functions and classes.

In Django templates, any template variables will use this double curly bracket syntax.
And any other kinds of functionality like for loops, for example, will use this
opening and closing curly bracket % sign syntax which looks like this.

We create a table surrounding the loop and for each item, in items, we create a row. 
And inside that row, we add 3 td elements:
1. the first td element will contain the item's name. So we use the template variable syntax and call it item.name 
2. the second td element will contain the items done status: item.done.

3. TOGGLE - the 1st button will give the user the ability to quickly toggle in items done status.
href on the link wrapping the button will point to a URL edit and also append "items.id" that is automatically generated by Django.
4. EDIT - the 2nd button will take us to the Edit item page. href on the link wrapping the button will 
point to a URL edit and also append "items.id" that is automatically generated by Django.

You need then to Create edit_item template and also create a view or a URL in views.py and urls.py files. 

The "if" statement will strike out the item if item is done.
Rather than rendering true or false for the done status.

what should happen if our database doesn't have any todo items in it?
To handle that we can use a special tag called "empty", right before the endfor tag.
After the empty tag all we want to do is render a single row with a 
single td element in it, which says you have nothing to do.

After the table closing tag, we add a link to access the add_item.html template. 

Next we need a view to display this template so let's go up to views.py

Go to settings.py, under the INSTALLED_APPS, add our "todo" app to the list of installed apps. 
And this is going to allow Django to look inside of that app folder for a templates directory.
-->